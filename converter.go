package main

import (
	"encoding/json"
	"fmt"
	"sort"
	"strconv"
	"time"
)

// Date layout in Go is based on a fixed date
// instead of using ambigous masks (yyyy-dd-mm, yadda-yadda)
// The fixed date is: Mon Jan 2 15:04:05 MST 2006  (MST is GMT-0700)
const dateLayout = "200601020304"

// Final data structure that is serialized and sent to Graphite
// Every field populates a new metric on Graphite side
type LogMinute struct {
	Timestamp   int64
	Connections int
	Sessions    int
	Selects     int
	Inserts     int
	Updates     int
	Deletes     int
	Max         float64
	Min         float64
	Duration    float64
}

// Creating a Container type for our Logs that
// can be sorted according timestamp (older, smaller timestamp, first)
type Logs []LogMinute

func (m Logs) Len() int {
	return len(m)
}
func (m Logs) Swap(i, j int) {
	m[i], m[j] = m[j], m[i]
}
func (m Logs) Less(i, j int) bool {
	return m[i].Timestamp < m[j].Timestamp
}

/*
 * JSON format generated by pgbadger:
 * {
 *   "per_minute_info": {
 *     "20150731": {
 *       "10": {
 *         "SELECT": {
 *           "count": 42,
 *           (...)
 *         },
 *         "INSERT": {
 *           (...)
 *         }
 *       },
 *       "11": {
 *         (...)
 *       }
 *     }
 *   }
 *  (...)
 * }
 */
type LogFile struct {
	PerMinuteInfo map[string]map[string]map[string]Counter `json:"per_minute_info"`
}

type HasCount struct {
	Count int
}

type Counter struct {
	Others     HasCount
	Select     HasCount
	Insert     HasCount
	Update     HasCount
	Delete     HasCount
	Connection HasCount
	Session    HasCount
	Query      struct {
		Duration float64
		Max      string
		Min      string
	}
}

// Convert min, max from string to float64
func convMinMax(counter Counter) (min, max float64) {
	maxStr := counter.Query.Max
	minStr := counter.Query.Min
	if minStr == "" {
		minStr = "0"
	}
	if maxStr == "" {
		maxStr = "0"
	}
	max, err := strconv.ParseFloat(maxStr, 64)
	if err != nil {
		log.Panic(err)
	}
	min, err = strconv.ParseFloat(minStr, 64)
	if err != nil {
		log.Panic(err)
	}
	return min, max
}

// Create a new LogLine for the given args
func newLogLine(moment time.Time, counter Counter) LogMinute {
	min, max := convMinMax(counter)
	return LogMinute{
		Timestamp:   moment.Unix(),
		Connections: counter.Connection.Count,
		Sessions:    counter.Session.Count,
		Selects:     counter.Select.Count,
		Inserts:     counter.Insert.Count,
		Updates:     counter.Update.Count,
		Deletes:     counter.Delete.Count,

		// For some weird reason we're getting the duration doubled
		Duration: counter.Query.Duration / 2,
		Min:      min,
		Max:      max,
	}
}

// Convert pgbadger generated logs to our LogMinute struct
func ConvertLogs(lines string) Logs {
	var logFile LogFile
	json.Unmarshal([]byte(lines), &logFile)

	var logs Logs
	for date, info := range logFile.PerMinuteInfo {
		for hour, info := range info {
			for min, info := range info {
				timeStr := fmt.Sprintf("%s%s%s", date, hour, min)
				moment, err := time.Parse(dateLayout, timeStr)
				if err != nil {
					log.Panic(err)
				}
				logs = append(logs, newLogLine(moment, info))
			}
		}
	}
	sort.Sort(logs)
	return logs
}
